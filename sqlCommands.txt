SQL Data types - 

1.CHAR and VARCHAR are same, different is that VARCHAR is variable...
2.BLOB denotes Binary Large Object files - Data stored in raw bytes, like images, videos etc...
3.INT, BIGINT, FLOAT and DOUBLE...
4.DATE,TIME, BOOLEAN, TIMESTAMP, BIT and DATETIME...

1. DDL - CREATE, DROP - delete the table or database object including its structure, TRUNCATE - delete all the tuples, RENAME, ALTER TABLE...
2. DML - INSERT, UPDATE, DELETE - can be rolled back if wrapped in a transaction...
3. DRL/DQL - SELECT...
4. DCL - GRANT, REVOKE...
5. TCL - COMMIT, ROLLBACK...

We can also run select command without using from command using concept of dual tables(dummy tables)...
SELECT 44+11;

WHERE CLAUSE - Narrow down the entries by using conditions with WHERE clause...
BETWEEN CLAUSE - Range based search with the help of WHERE and BETWEEN clause...
IN CLAUSE - Reduce multiple or by providing a list to IN...
AND, OR, NOT...
is NULL to check for NULL value and can't be checked by other clauses and returns a row...

We can also query through wildcards by using LIKE keyword:
1. '%p%', any no. of chars before p and after p can be there...
2. '_p%, underscore denotes just one character and after p any no. of chars...
3. '_p_', only 3 letter words are considerable in which p is the second character...

Sorting in SQL:
SELECT * FROM Customers ORDER BY age DESC;

Distinct values in SQL:
SELECT DISTINCT country FROM Customers ORDER BY age DESC;

Grouping in SQL:
If no aggregation function is applied, it works similarly to distinct command in SQL...
Aggregation - Reducing a large set of values into a single value...
1. COUNT(*) when you don't care about non-null values...
2. COUNT(columnName) when you care about non-null values...

SELECT 
customer_id, 
SUM(amount) as totalSum FROM Orders
GROUP BY customer_id;

GROUP BY HAVING:
Similar to WHERE but filtering is applied on groups...

SELECT 
item, 
SUM(amount) as totalSum FROM Orders
GROUP BY item HAVING item='Keyboard' OR item!='Mouse';

SQL Logical Query Execution Order:

FROM Clause:Identify the table(s) and perform any joins or subqueries. This defines the dataset to work with.
WHERE Clause:Filter rows based on conditions before any grouping or aggregation occurs.
GROUP BY Clause:Group the filtered rows based on the specified column(s). Each unique value or combination of values creates a group.
Aggregate Functions (SUM, COUNT, etc.):Compute aggregate values (like totals or counts) for each group.
HAVING Clause:Filter groups based on the results of aggregate functions.
SELECT Clause:Choose the columns or expressions to include in the result set. Any aliasing (e.g., AS) is applied here.
ORDER BY Clause:Sort the result set based on one or more columns or expressions.
LIMIT Clause (or FETCH/TOP):Restrict the number of rows returned in the final result.

DDL Constraints:

1. Primary Key: notNULL, Unique and only one for each table...
2. Foreign Key: refers PK of another table...
3. Unique Key...
4. Check -> CONSTRAINT constraintName CHECK(key>1000)
5. Default -> We can set default value...

ALTER TABLE:

1. ADD Column - ALTER TABLE account ADD newColumn NOT NULL default 0...
2. CHANGE, RENAME...

DML commands:
1. INSERT INTO account(id,name,gender) VALUES (1, 'Madhav', 'male'),(...),(...),(...);
2. UPDATE and SET, keep in mind SQL_SAFE_UPDATES variable if updating full table...
3. REPLACE

A referential constraint is a rule that maintains integrity b/w parent and child tables...
It maintains the consistency of data by enforcing relationship between PK and FK...

The referential constraint ensures that value of FK must either match PK in the referenced table
or be NULL if allowed by the schema...

Actions on referential constraints:

1. ON DELETE CASCADE: If a reference record is deleted then the corresponding FK records in the 
child table are also deleted...
1. ON UPDATE CASCADE: If a reference record is UPDATED then the corresponding FK records in the 
child table are also UPDATED...
2. ON DELETE SET NULL:  If a reference record is deleted then the corresponding FK records in the 
child table are set to NULL...
3. ON DELETE RESTRICT: Prevents the deletion of parent record if some FK corresponding to the PK exists...

REPLACE: Acts as insert if no such data exists else replaces the data...

Replace vs Update:
1. Replace adds new row if row doesn't exist but not the case with Update...

JOINS:
1. INNER JOIN: 
1.1:Returns the resultant table with common FK and PK values and merges both the tables...
1.2:So basically its intersection of both the tables based on the condition we will be providing...

2. OUTER JOIN:
2.1: LEFT JOIN: Returns all the data from the left table and matching data from the right table...
2.2: RIGHT JOIN: Returns all the data from the right table and matching data from the left table...
2.3: FULL JOIN: Union of both left and right JOIN, no keyword in SQL for it, have to seperately write left and right Join and 
do union of both of them...
2.4: CROSS JOIN: Cartesian Product...
2.5: SELF JOIN: Emulated through aliasing and Inner Join...

IMPORTANT:
1. Use Aggregation functions when you want group wise aggregation, like max salary in each department...
2. If you want to compare those individual rows inside a group, then use SELF JOIN... 
3. SELECT * FROM Students,Users will generate cartesian product of both the tables...

Doing Join without using JOIN keyword:
1. Just include other table as well...
   SELECT *
   FROM Orders as c1,Orders as c2
   WHERE c1.customer_id = c2.customer_id AND c1.amount<c2.amount;

SET Operations:

Combines two or more SELECT statements...

UNION:
1. Only possible if same no. of colns,compatible data types,coln names will taken from the first query, removes 
redundant row values,but you can have them if used with UNION all, but in JOINS Additional colns are also added...

2. Basically JOINS are column wise combination and UNION are row wise combination...
3. INTERSECT for intersection,provided only in SQLite...
4. MINUS - Needs to be emulated in SQLite and MYSQL...

Subqueries: 
1. Alternative to JOINS...
2. Outer query depends on inner Query...

Aggregate Functions can also have conditional satifying criteria as well through CASE WHEN condition THEN VALUES END

Creating a View:

CREATE VIEW CUSTOM_VIEW FROM SELECT First_Name,Last_Name FROM tableName;

Window Functions in SQL:

Window functions allow us to perform complex aggregation or calculation on rows related by some value
without altering the original view for the user...

They can be categorized into two types:
1. Ranking window functions...
2. aggregate window functions... - Same as normal aggregate functions...

SELECT *,AVG(salary) OVER(PARTITION BY department) AS AVG_SALARY
FROM tableName

Ranking Window Functions:

1. Rank(): Assigns rank to all rows in each partition, but if two rows have same values on which partition was 
applied then both of them have same rank in a partition and the next guy will be skipped with those much ranks.
For eg: If we have two guys in a partition with the same values on which partition was applied then both of them
will be assigned the same rank in a partition but after that the third guy will get rank 3 and not 2...

2. DENSE_RANK(): 3rd guy will get rank 2 only...

3. ROW_NUMBER(): Within each partition consecutive numbers...

NULL denotes - Absence of a value...
"" - It represents a value which is intentionally set as an empty string...

General Syntax for a Window Function:

<windowFunction>
         OVER< PARTITION BY <>
               ORDER BY <>
               ROWS <>
             >



